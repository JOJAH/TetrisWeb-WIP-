<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <div id="tetrisContainer"></div>

<style>
    body{
        display: flex;
        justify-content: center;
    }
    #tetrisContainer{
        display: grid;
        grid-template-columns: repeat(10, 20px);
        
    }
    .cell{
        border: 1px solid black;
        height: 20px;
    }

</style>

<script>
    const numColumns = 10;
    const numRows = 20;

    const container = document.getElementById('tetrisContainer');
    for(let i = 0; i < numColumns*numRows; i++){
        const cell = document.createElement('div');
        cell.setAttribute('class','cell')
        container.appendChild(cell)
    }

    const Tetrads = {
        I: [
            [1,1,1,1]
        ],

        J: [
            [1,0,0],
            [1,1,1],
        ],

        L: [
            [1,1,1],
            [1,0,0]
        ],

        O: [
            [1,1],
            [1,1]
        ],

        S: [
            [0,1,1],
            [1,1,0]
        ],
    
        Z: [
            [1,1,0],
            [0,1,1]
        ],

        T: [
            [1,1,1],
            [0,1,0]
        ]
    }
    const TetradColours = {
        I: 'rgb(43, 202, 226)',
        J: 'rgb(15, 9, 190)',
        L: 'rgb(240, 109, 44)',
        O: 'rgb(216, 181, 22)',
        S: 'rgb(99, 223, 23)',
        Z: 'rgb(228, 54, 54)',
        T: 'rgb(198, 23, 207)',
    }

    // set grid elements to empty
    let grid = [];
    for(let i=0; i< numRows; i++ ){
        row = Array(numColumns).fill(0);
        grid.push(row);
    }

    function getRandomTetrad(){
        const tetradKeys = Object.keys(Tetrads)
        const tetrad = tetradKeys[Math.floor(Math.random()*7)]
        if(tetrad == 'I'){
            lowestPoint = -1;
        }else{
            lowestPoint = 0;
        }
        if(tetrad == 'O'){
            x = 4;
        }else{
            x =3;
        }

        return {
            type:tetrad,
            shape:Tetrads[tetrad],
            colour: TetradColours[tetrad],
            x: x,
            y: 0,
            lowestPoint: lowestPoint
        }
    }

let cells = document.getElementsByClassName('cell')

    function createTetrad(){
        const {shape, colour, x , y} = activeTetrad;
        shape.forEach((row, i) =>{
            row.forEach((cell, j)=>{
                if(cell == 1){
                    index = (y+i) * numColumns + (x + j);
                    cells[index].style.background = colour
                    cells[index].classList.add('moving');
                }
            });
        });
    }

    function removeTetrad(){
        const {shape, colour, x , y} = activeTetrad;
        shape.forEach((row, i) =>{
            row.forEach((cell, j)=>{
                if(cell == 1){
                    index = (y + i) * numColumns + (x + j);
                    cells[index].style.removeProperty('background');
                    cells[index].classList.remove('moving');
                }
            });
        });
    }

    function checkCollision(){
        const {shape, x ,y, lowestPoint} = activeTetrad;
        if(lowestPoint >= numRows-1){
            activeTetrad.y--;
            return true;
        }

        for(let i = 0; i < shape.length; i++){
            for(let j = 0; j < shape[i].length; j++){
                if(shape[i][j] == 1){
                    lowerY = y+i;
                    if(grid[lowerY][x+j] == 1){
                        activeTetrad.y--
                        return true
                    }
                }
            }
        }
    }

    function placeTetrad(){
        const {shape, x ,y} = activeTetrad;
        shape.forEach((row, i)=>{
            row.forEach((cell, j) =>{
                if(cell == 1){
                    grid[y+i][x+j] = 1

                // Completed row check    
                    if(!grid[y+i].includes(0)){


                            for(let row = y+i; row>0; row--){
                                for(let col = 0; col <numColumns; col++){
                                    grid[row][col] = grid[row-1][col];
                                    const cell = cells[row * numColumns + col];
                                    const cellAbove = cells[(row-1) * numColumns + col];
                                    if(grid[row][col]===1){
                                        cell.style.background = cellAbove.style.background;
                                    }else{
                                        cell.style.removeProperty('background');
                                    }
                                }
                            }
                            
                        

                    }
                    
                }
            });
        });
        
    }


    function moveTetradDown(){
        removeTetrad();
        activeTetrad.y++;
        activeTetrad.lowestPoint++;
        
        if(checkCollision()){
            createTetrad();
            placeTetrad();
            activeTetrad = getRandomTetrad();
        }
        createTetrad();
        if(checkCollision()){
            clearInterval(runGame);
        }
    }


    function rotateTetrad(){
        let {shape, x , y, lowestPoint} = activeTetrad;

        const rotatedColumn = shape.length;
        const rotatedRow = shape[0].length;
        const yDifference = rotatedRow-rotatedColumn;
        const newLowestPoint = lowestPoint + yDifference
   
        let rotatedShape = []
        for( let col = 0; col < rotatedRow; col++){
            newRow = [];
            for( let row = rotatedColumn -1 ; row >= 0; row--){ // iterates downwards as to rotate 90 degrees 
                newRow.push(shape[row][col]);
            
            //rotation collision check
                let newX = x + row;
                let newY = y+ col;
                if(grid[newY][newX] == 1){
                   return
                }
            }
            rotatedShape.push(newRow)
        }
    //stop tetrad rotatoing over the right border
        if(rotatedShape[0].length + x >= numColumns){
            x = numColumns - rotatedShape[0].length;
        }



        removeTetrad();
        activeTetrad.shape = rotatedShape
        activeTetrad.x = x
        activeTetrad.lowestPoint =  newLowestPoint
        createTetrad();
    }
    

    function moveLeft(){
        let {shape, x , y} = activeTetrad;
        if(x > 0){
        //adds collision for moving terads with placed tetrads when moving left
        for(let i = 0; i < shape.length; i++){
            for(let j = 0; j < shape[i].length; j++){
                if(shape[i][j] == 1){
                    const leftX = x - 1 + j;
                    if(grid[y+i][leftX] == 1){
                        return
                    
                    }
                }
            }
            
        }
        removeTetrad();
            activeTetrad.x--;
            createTetrad();
        }
    }
    function moveRight(){
        let {shape, x , y} = activeTetrad;
        //stop right side overspill
        const width = activeTetrad.shape[0].length;
            if(activeTetrad.x < numColumns - width){

            //adds collision for moving terads with placed tetrads when moving Right
                for(let i = 0; i < shape.length; i++){
                    for(let j = 0; j < shape[i].length; j++){
                        if(shape[i][j] == 1){
                            const rightX = x + 1 + j;
                            if(grid[y+i][rightX] == 1){
                                return
                            }
                        }
                    }
            
                }   
                removeTetrad();
                activeTetrad.x++;
                createTetrad();
                }

    }
    function moveDown(){
        removeTetrad();
        activeTetrad.y++;
        activeTetrad.lowestPoint++;
        if(checkCollision()){
            createTetrad();
            placeTetrad();
            activeTetrad = getRandomTetrad();
        }
        createTetrad();
        if(checkCollision()){
            clearInterval(runGame);
        }
    }


document.addEventListener('keydown', (event)=>{
    if(event.key === 'ArrowUp' || event.key === 'w'){
        rotateTetrad()
    }
    if(event.key === 'ArrowLeft' || event.key === 'a'){
        moveLeft();
    }
    if(event.key === 'ArrowRight' || event.key === 'd'){
        moveRight();
    }
    if(event.key === 'ArrowDown' || event.key === 's'){
        moveDown();
    }
});

let activeTetrad = getRandomTetrad()

createTetrad()

let gameSpeed = 1000;
let runGame = setInterval(moveTetradDown, gameSpeed);

</script>

</body>
</html>